function [S1, S2, Rd, Vd] = signal_target1(EQ64, EQ256)
    %инициализация матриц
    ZOND(1:25000,1:64) = 0;     %зондирующий сигнал
    S1_RX(1:25000,1:64) = 0;    %сигнал, принятый первой антенной
    S2_RX(1:25000,1:64) = 0;    %сигнал, принятый втрой антенной
    S1_SM(1:25000,1:64) = 0;    %сигнал на выходе смесителя 1
    S2_SM(1:25000,1:64) = 0;    %сигнал на выходе смесителя 2
    S1(1:256,1:64) = 0;         %сигнал 1 после АЦП
    S2(1:256,1:64) = 0;         %сигнал 2 после АЦП

    c = 3*10^8; %скорость света
    B = 50*10^6; %полоса модуляции в Гц
    fm = 8*10^3; %частота повторения пилы в Гц    
    tau0 = 1300*10^-9; %задержка сигнала до максимальной дальности в м
    f0 = 24e9; %несущая частота
    
    Tm = 1/fm; %период повторения пилы
    fb0 = B*tau0/Tm; %дальностная частота до максимальной дистанции
    Rd = c/(2*B); %разрешение по дальности
    Vd = (fm*c)/(2*EQ64*f0);  %разрешение по скорости
    kk = 5*10^-9; %специальный коэффициент
    I = Tm/kk; %количество отсчетов в одном периоде пилы
    
    %Модель сигнала
    b = B/Tm; %коэффициент ЛЧМ
    FF = EQ64; %количество накапливаемых периодов
    mu=0; %мат.ожидание
    sigma=0.1; %СКО
    RAND=(mu+sigma.*randn(1,1));
    
    % Для задания требуемого числа целей нужно изменять переменную N.
    % (Пример: N = 3; - 3 цели).
    % Для каждой цели прописать параметры аналогично коду из рамки Цель1,
    % заменяя индексы в скобках номером цели
    
    N = 1; %кол-во целей
    %Инициализация массивов нулями для ускорения расчетов
    fd(1:N) = 0; 
    R(1:N) = 0; 
    tau(1:N) = 0; 
    fb(1:N) = 0; 
    J(1:N) = 0;
    phi_grad(1:N) = 0;
    phi(1:N) = 0;
    
    % ЦЕЛЬ 1. Параметры начало
    V(1) = -2*Vd; % скорость цели, м/с
    R(1) = 100; %дальность до цели, м
    phi(1) = 45*pi/180; %угол пеленга в градусах
    % ЦЕЛЬ 1. Параметры конец
       
    %Зондирующий сигнал
    for i=0:1:I-1
        t = i*kk;
        for j = 0:1:FF-1
            ZOND(i+1,j+1) = cos(2*pi*f0*t + pi*B*(t - j*Tm)^2/Tm);
        end;
    end;  
    
    frx1 =  2*pi/180;
    frx2 = -2*pi/180;
    l = sqrt(-1);
    %Сигналы, принытые антенной
    for i=0:1:I-1
        for j = 0:1:FF-1
            t = i*kk;
            for z = 1:1:N
                td(z) = 2*(R(z) + V(z)*t)/c;
                S1_RX(i+1,j+1) = cos(2*pi*f0*(t-td) + pi*B*(t - td - j*Tm)^2/Tm);   
                S2_RX(i+1,j+1) = cos(2*pi*f0*(t-td) + pi*B*(t - td - j*Tm)^2/Tm);             
            end;
        end;
    end;
    
    %Сигналы на выходе смесителя
    for i=0:1:I-1
        for j = 0:1:FF-1    
            S1_SM(i+1,j+1)=(ZOND(i+1,j+1)*S1_RX(i+1,j+1)); 
            S2_SM(i+1,j+1)=(ZOND(i+1,j+1)*S2_RX(i+1,j+1));
        end;
    end; 
       
    
    rsm_p = 2; % нужно для преобразования сигнала в EQ256 отсчетов
    rsm_q = double(int16(rsm_p*size(S1_SM,1)/EQ256));
    S1=resample(S1_SM,rsm_p,rsm_q); % пересчет (дискретизация) сигнала
    S2=resample(S2_SM,rsm_p,rsm_q); % пересчет (дискретизация) сигнала 
    while (size(S1,1) > EQ256) % если пересчет дал больше 256 точек
        S1(size(S1,1),:) = []; %модель сигнала после АЦП
    end;
    while (size(S2,1) > EQ256) % если пересчет дал больше 256 точек
        S2(size(S2,1),:) = []; %модель сигнала после АЦП
    end;
end